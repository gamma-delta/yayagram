// some old code of an attempt of making a main menu. It worked out but eventually I decided that maybe it was too much and simplicity mattered too

use crate::{
    event,
    grid::{
        builder::{Builder, Cursor},
        Cell, Grid,
    },
};
use half_block::Canvas;
use std::{env, io, time};
use terminal::{
    util::{Color, Point},
    Terminal,
};

pub fn run(terminal: &mut Terminal) {
    terminal.clear();

    terminal.deinitialize();
    let grid = Grid::from_lines(&["1   1", "1   1", "1   1", "1   1", "1   1"]);

    let mut builder = Builder::new(&terminal, grid);
    builder.draw(terminal);

    // let lines = ["111 1", "11111", "1 111"];
    // let grid = Grid::from_lines(&lines);
    // event::await_fitting_size(terminal, &grid);
    // let mut builder = Builder::new(&terminal, grid);
    // builder.draw(terminal);
}


    let mut canvas = Canvas::new(&terminal.size);

    const YAYAGRAM: &str = r#"W W WWW W W WWW WWW WWW WWW W W
W W W W W W W W W   W W W W WWW
 W  WWW  W  WWW W W WW  WWW WWW
 W  W W  W  W W WWW W W W W W W"#;

    let max_line_width = YAYAGRAM.lines().map(|line| line.len()).max().unwrap() as u16;

    for (y, line) in YAYAGRAM.lines().enumerate() {
        for (x, char) in line.chars().enumerate() {
            if char == 'W' {
                let x_center = (terminal.size.width / 2 - max_line_width / 2) + x as u16;
                let y = (terminal.size.height / 3) + y as u16;
                canvas.half_block(&mut terminal, Point { x: x_center, y: y }, Color::White);
                terminal.reset_colors();
            }
        }
    }

    use terminal::event::{Event, KeyEvent};

    #[derive(Clone)]
    struct Button {
        text: &'static str,
    }
    impl Button {
        fn new(text: &str) -> Self {
            Self { text }
        }
    }
    fn select_from(terminal: &mut Terminal, buttons: &[Button]) -> usize {
        fn draw(terminal: &mut Terminal, buttons: &[Button], selected: usize) {
            for (index, button) in buttons.iter().enumerate() {
                let x_center = (terminal.size.width / 2 - button.text.len() as u16 / 2) as u16;
                let y = (terminal.size.height / 3) as u16 + index as u16 * 2;

                terminal.set_cursor(Point { x: x_center, y });
                if selected - 1 == index as usize {
                    terminal.set_background_color(Color::White);
                    terminal.set_foreground_color(Color::Black);
                } else {
                    terminal.set_foreground_color(Color::White);
                }
                terminal.write(button.text);
                terminal.reset_colors();
                terminal.flush();
            }
        }
        let mut selected = 1;
        draw(terminal, buttons, selected);
        loop {
            let event = terminal.read_event();
            if let Some(Event::Key(key)) = event {
                match key {
                    KeyEvent::Char('w', None) | KeyEvent::Char('W', None) | KeyEvent::Up => {
                        if selected == 1 {
                            selected = buttons.len();
                        } else {
                            selected -= 1;
                        }
                    }
                    KeyEvent::Char('s', None) | KeyEvent::Char('S', None) | KeyEvent::Down => {
                        if selected == buttons.len() {
                            selected = 1;
                        } else {
                            selected += 1;
                        }
                    }
                    KeyEvent::Enter | KeyEvent::Char(' ', None) => {
                        return selected - 1;
                    }
                    _ => continue,
                }
                draw(terminal, buttons, selected);
            }
        }
    }
    let buttons = &[
        Button::new("Standard"),
        Button::new("Tutorial"),
        Button::new("Editor"),
        Button::new("Exit"),
    ];
    let selected_button_index = select_from(&mut terminal, buttons);
    match selected_button_index {
        1 => {
            tutorial::run(&mut terminal);
        }
        _ => {
            terminal.deinitialize();
            std::process::exit(0);
        }
    }

    // let y = (terminal.size.height / 2) as u16;
    // terminal.write("Standard");
    // (&mut terminal, Point { x: x_center, y: y }, Color::White);
    //terminal.reset_colors();

    terminal.flush();

    event::await_key(&mut terminal);

    terminal.deinitialize();
    return;
